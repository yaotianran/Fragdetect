# use lowess regression to correct and fragment length distribution by GC ratio in 5M windows
# bin_100K, bin_5M  are both size count matrics generated by "collect_bin_size_ratio". They must have euqal columns
# the detail of the format of count matrix, see collect_bin_size_ratio

# the function first fit a lowess regression model with size ratio ~ GC in train, and correct the size ratio in test
#
# the output is N x n-1 float data frame
# N is length if 5M regions
# columns are short/media/long size fragments count ratio

# TODO list: outliers detection
GC_correct <- function(bin_100K, bin_5M, span = 0.75, plot.folder = 'plots', id = 'sample') {

   # x_train, y_train is the fragments GC ratio and fragment length ratio in 100K windows
   # x_predict, y_predict is the fragments GC ratio and fragment length ratio in 5M windows
   # span is the span value of lowess model
   # return a "corrected version" of y_predict (fragment length ratio in 5M windows)
   ..predict.lowess <- function(x_train, y_train, x_predict, y_predict, span, plot.folder, id) {
      x = data.frame(x_train = x_train)
      y = data.frame(y_train = y_train)
      temp.df = merge(x, y, by = 0, all = F)
      x_train = temp.df$x_train
      names(x_train) = temp.df$Row.names
      y_train = temp.df$y_train
      names(y_train) = temp.df$Row.names

      trend.train <- loess(y_train ~ x_train, data = temp.df, span = span)
      #trend.train <- loess(y_train ~ x_train, span = span, weights = abs(y_sd/(y_train - y_mean)))

      i <- seq(min(x_train, na.rm = T), max(x_train, na.rm = T), length.out = 1000)
      predict.train.c = predict(trend.train, i)
      plot(x_train, y_train, cex = 0.3, pch = 20, xlab = 'GC ratio', ylab = 'Fragments ratio', main = sprintf('%s (raw)', id))
      points(i, predict.train.c, cex = 0.5, pch = 20, col = 'blue')
      lines(i, predict(trend.train, i), col = 'blue', cex = 0.5)
      trend.train.smooth <- loess(predict.train.c ~ i, span = span)
      predict.smooth.c = predict(trend.train.smooth, i)
      lines(i, predict.smooth.c, col = 'red', cex = 0.5)

      bias <- predict(trend.train.smooth, x_predict)
      points(x_predict, bias, col = 'red', cex = 0.7, pch = 20)

      y_corrected <- y_predict - bias + median(y_predict, na.rm = T)
      trend.correct <- loess(y_corrected ~ x_predict, span = span)
      predict.smooth.c = predict(trend.correct, i)

      plot(x_predict, y_predict, cex = 0.3, pch = 21, xlab = 'GC ratio', ylab = 'Fragments ratio', main = sprintf('%s (corrected)', id))
      #points(x_predict, bias, col = 'red', cex = 0.5, pch = 20)
      points(x_predict, y_corrected, col = 'blue', cex = 0.7, pch = 19)
      lines(i, predict.smooth.c, col = 'red', lwd = 2)

      #y_corrected <- y_predict - bias
      return(y_corrected)
   }

   if (ncol(bin_100K) != ncol(bin_5M)) {
      message('The column number of two input are not same.')
      quit(save = 'no', status = -1)
   }

   output.df = data.frame(matrix(nrow = nrow(bin_5M), ncol = 0))
   M = ncol(bin_100K) - 1
   x_train = bin_100K[, 1]  # GC of train data
   x_predict = bin_5M[, 1]  # GC of test data
   for (i in 2:M) {
      y_train = bin_100K[, i] / bin_100K[, ncol(bin_100K)] # ratio of train data
      y_predict = bin_5M[, 1] / bin_5M[, ncol(bin_5M)] # ratio of test data
      y_corrected = ..predict.lowess(x_train, y_train, x_predict, y_predict, span, plot.folder, id = paste(id, i - 1))
      output.df = cbind(output.df, data.frame(y_corrected))
   }
   colnames(output.df) = paste0('I', 1:ncol(output.df))

   return(output.df)
}



